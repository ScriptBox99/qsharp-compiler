# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.


from .formatting import main as style_check_main
from .builder import main as builder_main
from .linting import main as lint_main, clang_tidy_diagnose

import click
import logging
import sys
import os

LIB_DIR = os.path.abspath(os.path.dirname((__file__)))
TEMPLATE_DIR = os.path.join(LIB_DIR, "templates")
SOURCE_DIR = os.path.abspath(os.path.dirname(os.path.dirname(LIB_DIR)))
logger = logging.getLogger()

# Logging configuration
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

# By default we only log errors
logger.setLevel(logging.ERROR)


@click.group()
@click.option('--loglevel', default="error")
def cli(loglevel):
    levels = {
        "critical": 50,
        "error": 40,
        "warning": 30,
        "info": 20,
        "debug": 10,
        "notset": 0
    }

    loglevel = loglevel.lower()
    if loglevel not in levels:
        logger.critical("Invalid log level")
        sys.exit(-1)

    logger.setLevel(levels[loglevel])
    logger.info("Loglevel set to {}".format(loglevel))


@cli.command()
@click.option('--fix-issues', default=False, is_flag=True)
def stylecheck(fix_issues):
    logger.info("Invoking style checker")

    style_check_main(fix_issues)


@cli.command()
@click.option("--diagnose", default=False, is_flag=True)
@click.option('--fix-issues', default=False, is_flag=True)
@click.option('--force', default=False, is_flag=True)
def lint(diagnose, fix_issues, force):
    if diagnose:
        clang_tidy_diagnose()
        return

    if fix_issues:
        if not force:
            print("""Fixing isssues using Clang Tidy will break your code.
Make sure that you have committed your changes BEFORE DOING THIS.
Even so, this feature is experimental and there have been reports of
clang-tidy modying system libraries - therefore, USE THIS FEATURE AT
YOUR OWN RISK.

Write 'I understand' to proceed.""")
            print(":")
            x = input()
            if x.lower() != "i understand":
                print("Wrong answer - stopping!")
                exit(-1)

    logger.info("Invoking linter")
    lint_main(fix_issues)


@cli.command()
@click.option('--debug/--no-debug', default=True)
@click.option('--generator', default=None)
def test(debug, generator):
    logger.info("Building and testing")

    build_dir = "Debug"
    if not debug:
        build_dir = "Release"

    builder_main(build_dir, generator, True)


@cli.command()
def runci():
    build_dir = "Debug"

    style_check_main(False)
    lint_main(False)
    builder_main(build_dir, None, True)


@cli.command()
@click.argument(
    "name"
)
@click.option(
    "--template",
    default="basic",
)
def create_pass(name, template):

    target_dir = os.path.join(SOURCE_DIR, "libs", name)
    if os.path.exists(target_dir):
        logger.error("Pass '{}' already exists".format(name))
        exit(-1)

    if template is None:
        raise BaseException("Choice is not implemented yet")

    template_dir = os.path.join(TEMPLATE_DIR, template)
    if not os.path.exists(template_dir):
        logger.error("Template not found")
        exit(-1)

    logger.info(" ".join(["Creating", name, "in", target_dir]))
    os.makedirs(target_dir)

    for root, dirs, files in os.walk(template_dir):

        # Creating dirs
        for d in dirs:
            os.makedirs(os.path.join(target_dir, d))

        # Generating files
        for f in files:
            src = os.path.join(root, f)
            dest = os.path.join(target_dir, f).format(name=name)

            with open(src, "r") as fb:
                contents = fb.read()

            contents = contents.replace("{{name}}", name)
            contents = contents.replace("{{name}}", name)

            # with open(dest, "w") as fb:
            #    fb.write(contents)

            logger.info("- Wrote {}".format(dest))


if __name__ == '__main__':
    cli()
