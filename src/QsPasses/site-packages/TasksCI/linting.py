# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

import logging
from .builder import configure_cmake, build_project
from . import toolchain
from .settings import PROJECT_ROOT
import os
import subprocess
import sys

logger = logging.getLogger("Linter")


def clang_tidy_diagnose():
    config = subprocess.check_output(
        [toolchain.discover_tidy(), '-dump-config'], cwd=PROJECT_ROOT).decode()

    check_list = subprocess.check_output(
        [toolchain.discover_tidy(), '-list-checks'], cwd=PROJECT_ROOT).decode()

    checks = [x.strip() for x in check_list.split("\n") if '-' in x]

    print("Working directory: {}".format(PROJECT_ROOT))
    print("")
    print(config)
    print("")
    print("Clang tidy checks:")
    for check in sorted(checks):
        print(" -", check)


def run_clang_tidy(source_dir, build_dir, filename, fix_issues: bool = False):
    clang_tidy_binary = toolchain.discover_tidy()

    cmd = [clang_tidy_binary]
    output_file = os.path.abspath(os.path.join(build_dir, 'clang_tidy_fixes.yaml'))

    cmd.append('-header-filter=".*(QsPasses)\\/(src).*\\.hpp$"')
    cmd.append('-p=' + build_dir)
    cmd.append('-export-fixes={}'.format(output_file))
    cmd.append('--use-color')

    if fix_issues:
        cmd.append("-fix")

    cmd.append(filename)

    p = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=PROJECT_ROOT)

    output, err = p.communicate()

    if p.returncode != 0:
        output = output.decode()
        err = err.decode()

        if "error" in err:
            # TODO(TFR): write output and errors to temp log file
            sys.stderr.write(output)
            sys.stderr.write(err)

            logger.error("{} failed static analysis".format(filename))
            return False

    logger.info("All good!")
    return True


def main_cpp(fix_issues: bool):
    logger.info("Linting")
    build_dir = os.path.join(PROJECT_ROOT, "Debug")
    source_dir = os.path.join(PROJECT_ROOT, "src")
    generator = None
    extensions = ["cpp"]

    # Configuring CMake
    configure_cmake(build_dir, generator)

    # Building
    build_project(build_dir, generator)

    # Generating list of files
    # TODO(TFR): Ensure that it is only those which were changed that are
    # analysed
    files_to_analyse = []

    for root, dirs, files in os.walk(source_dir):

        for filename in files:
            if "." not in filename:
                continue

            _, ext = filename.rsplit(".", 1)
            if ext in extensions:
                files_to_analyse.append(os.path.join(root, filename))

    success = True
    for filename in files_to_analyse:
        success = success and run_clang_tidy(source_dir, build_dir, filename, fix_issues=fix_issues)
    return success


def main(fix_issues: bool):
    if not main_cpp(fix_issues):
        sys.exit(-1)
